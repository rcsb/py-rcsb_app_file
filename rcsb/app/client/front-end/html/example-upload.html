<!DOCTYPE html>
<html lang="en">
	<head>
        <meta charset="UTF-8">
        <title>HTML UPLOAD EXAMPLE</title>
        <!-- author James Smith j-s-135 -->
        <script src = "http://www.myersdaily.org/joseph/javascript/md5.js"></script>
		<script type="text/javascript">
			async function handleform() {
              window.event.preventDefault();
              let base_url = "http://0.0.0.0:8000";
              let upload_parameters_url = `${base_url}/file-v2/getSaveFilePath/`;
              let upload_id_url = `${base_url}/file-v2/getNewUploadId/`;
              let sequential_chunk_url = `${base_url}/file-v2/upload/`;
              let jwt_token = '';
              let file = document.getElementsByName('uploadFile')[0].files[0];
              let fileName = file.name;
              console.log(`file name ${file.name} modified ${file.lastModified} size ${file.size}`);
              // hash file
              // if file is a zip file, file has been compressed before hashing/upload
              let hashDigest = null;
              let filePath = null;
              let chunkIndex = 0;
              let uploadId = null;
              await getHashDigest(file);

              async function getHashDigest(file){
                var reader = new FileReader();
                reader.addEventListener("load", async () => {
                    hashDigest = md5(reader.result);
                    await getSaveFilePath().then(() => getUploadStatus()).then(() => getNewUploadId()).then(() => upload(file));
                });
                reader.readAsBinaryString(file);
              }

              async function getSaveFilePath() {
                  // get server-side parameters
                let repositoryType = document.getElementsByName('repositoryType')[0].value;
                let depId = document.getElementsByName('depId')[0].value;
                let contentType = document.getElementsByName('contentType')[0].value;
                let milestone = document.getElementsByName('milestone')[0].value;
                let partNumber = document.getElementsByName('partNumber')[0].value;
                let contentFormat = document.getElementsByName('contentFormat')[0].value;
                let version = document.getElementsByName('version')[0].value;
                let allowOverwrite = document.getElementsByName('allowOverwrite')[0].checked;
                let query = `?repositoryType=${repositoryType}&depId=${depId}&contentType=${contentType}&milestone=${milestone}&partNumber=${partNumber}&contentFormat=${contentFormat}&version=${version}&allowOverwrite=${allowOverwrite}`
                let url = upload_parameters_url + query
                await fetch(url, {
                    method: "GET",
                    headers: {"Authorization": `Bearer ${jwt_token}`}
                }).then(data => data.json()).then(json => {filePath = json.filePath;}).catch(err => console.log(err));
              }

              async function getUploadStatus(){
                  // get client-side parameters
                  let resumable = document.getElementsByName('resumable')[0].checked;
                  if(! resumable){
                      console.log('not a resumable upload');
                      return;
                  }
                  if(typeof(Storage) !== 'undefined') {
                      if(localStorage.getItem(hashDigest) !== null){  //(localStorage.uploadId && localStorage.uploadCount){
                          ls = JSON.parse(localStorage.getItem(hashDigest));
                          console.log(`detected previous upload ${hashDigest} having ${ls.uploadCount} chunks with id ${ls.uploadId}`);
                          uploadId = ls.uploadId;
                          chunkIndex = Number(ls.uploadCount) + 1;
                      } else {
                          console.log(`no previous upload was detected for ${hashDigest}`);
                      }
                  } else {
                      console.log('error - browser does not have local storage');
                  }
              }

              async function getNewUploadId(){
                  if(uploadId){
                      return;
                  }
                  let url = upload_id_url;
                  await fetch(url, {
                      method: "GET",
                      headers: {"Authorization": `Bearer ${jwt_token}`}
                  }).then(data => data.json()).then(json => {uploadId = json.uploadId}).catch(err => console.log(err));
              }

              async function upload(file){
                  if(! filePath){
                    console.log('error - could not read file path, or target file may already exist');
                    return;
                  }
                var fileSize = file.size;
                var chunkSize = 1024 * 1024 * 8; // bytes
                var expectedChunks = Math.ceil((fileSize) / chunkSize);
                var chunkOffset = chunkIndex * chunkSize;
                var hashType = "MD5";
                let decompress = document.getElementsByName('decompress')[0].checked;
                let allowOverwrite = document.getElementsByName('allowOverwrite')[0].checked;
                let resumable = document.getElementsByName('resumable')[0].checked;
                console.log(`chunk index ${chunkIndex} expected ${expectedChunks} for ${fileName} ${uploadId} ${filePath}`)
                readChunks(chunkIndex, chunkOffset, resumable);

                function readChunks(chunkIndex, chunkOffset, resumable) {
                  if (chunkIndex >= expectedChunks) {
                      // cleanup
                      console.log('clearing database');
                      localStorage.removeItem(hashDigest);
                      return;
                  }
                    // remove comments (then re-comment) to test resumable upload
                    // if(chunkIndex >= 3){
                    //     return;
                    // }
                  console.log(`posting chunk ${chunkIndex} of ${expectedChunks}`);
                  var blob = file.slice(chunkOffset, chunkOffset + chunkSize);
                  postChunk(blob, resumable);
                }

                async function postChunk(blob, resumable) {
                  var chunk = blob;
                  var chunksize = blob.size;
                  if (chunksize <= 0) {
                    return;
                  }
                  formdata = new FormData();
                  // chunk parameters
                  formdata.append("chunk", chunk);
                  formdata.append("chunkSize", chunkSize);
                  formdata.append("chunkIndex", chunkIndex);
                  formdata.append("expectedChunks", expectedChunks);
                  // upload file parameters
                  formdata.append("uploadId", uploadId);
                  formdata.append("hashType", hashType);
                  formdata.append("hashDigest", hashDigest);
                  // formdata.append("resumable", resumable);
                  // save file parameters
                  formdata.append("filePath", filePath);
                  formdata.append("decompress", decompress);
                  formdata.append("allowOverwrite", allowOverwrite);
                  if (resumable) {
                          params = JSON.stringify({'uploadId': uploadId, 'uploadCount': `${chunkIndex}`})
                          localStorage.setItem(hashDigest, params);
                  }
                  fetch(sequential_chunk_url, {
                    method: "POST",
                    headers: {"Authorization": `Bearer ${jwt_token}`},
                    body: formdata
                  }).then(response => {
                      if(response) {
                          chunkOffset += chunkSize;
                          chunkIndex = chunkIndex + 1;
                          readChunks(chunkIndex, chunkOffset, resumable);
                      }
                  }).catch(err => console.log(`response returned error ${err}`));
                }
              }
            }
        </script>
		<style>
			div {
				display: flex;
				flex-direction: column;
				align-items: center;
			}
			form {
				display: flex;
				flex-direction: column;
				align-items: flex-start;
				row-gap: 5px;
				border: 1px solid black;
				padding: 20px;
			}
		</style>
	</head>
	<body>
		<div>
		<form action="http://0.0.0.0:8000/file-v2/upload" method="POST" enctype="multipart/form-data" onsubmit="return handleform();">
			<label>Upload file</label>
			<input type="file" name="uploadFile">
            <label>Repository type</label>
            <input type="text" name="repositoryType">
            <label>Deposit id</label>
            <input type="text" name="depId">
            <label>Content type</label>
            <input type="text" name="contentType">
            <label>Milestone</label>
            <input type="text" name="milestone">
            <label>Part number</label>
            <input type="text" name="partNumber">
            <label>Content format</label>
            <input type="text" name="contentFormat">
            <label>Version</label>
            <input type="text" name="version">

            <table>
                <tr>
                    <td>
                        <input type="checkbox" name="allowOverwrite">
                    </td>
                    <td>
                         <label>Overwrite</label>
                    </td>
                </tr>
                <tr>
                    <td>
                         <input type="checkbox" name="decompress">
                    </td>
                    <td>
                         <label>Decompress zip file after upload</label>
                    </td>
                </tr>
                <tr>
                    <td>
                         <input type="checkbox" name="resumable">
                    </td>
                    <td>
                         <label>Resumable upload</label>
                    </td>
                </tr>
            </table>

            <input type="submit" value="submit">
            <input type="reset" value="reset">
		</form>
		</div>
	</body>
</html>